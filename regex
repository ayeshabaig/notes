^ and $
grep '^Graham' filename.txt - search for Graham at the beginning of the line
sudo grep 'nologin$' /etc/passwd - search /etc/passwd file for lines that end in 'nologin'
sed -i -r '/^\s*$/d' access-logs
sed -i -r -> invoke sed to edit a file in place using ERE
'/ -> namespace separator
^ -> match beginning of line
\s* -> match any ammount of whitespace (space, tab, carriage return, newline)
$ -> match end of line
/d -> delete matched pattern
access-logs -> targeted file to run script against

Boundaries - use \b to denote boundaries of words and nonwords
grep '\bVan\b' customer-data.txt
Opening boundary; any character before this cannot be a "word" character (matched with \w)
Closing boundary; any character after this cannot be a "word" character (matched with \w)
\B matches the opposite of \b
vim uses '\<Van\>' instead of '\bVan\b'

grep -Ei '\b(NJ|PA)\b' customer-data.txt
-E -> use ERE - extended regular expressions
-i -> case insensitive search
\b -> boundary
(NJ|PA) -> search for NJ or PA
\b -> boundary
customer-data.txt -> file to search against

Repitition
https?:\/\/(www\.)?([a-zA-Z0-9][a-zA-Z0-9\-]*)\.([a-zA-Z0-9]{2,63})\/?([a-zA-Z0-9][a-zA-Z0-9\-]*)?
? -> mark preceding token or subexpression as optional
+ -> repeat preceding token or subexpression 1 or more times
* -> repeat preceding token or subexpression 0 or more times
{2,63} -> repeat preceding token or subexpression 2-63 times
grep -Po 'https?:\/\/(www\.)?([a-zA-Z0-9][a-zA-Z0-9\-]*)\.([a-zA-Z0-9]{2,63})\/?([a-zA-Z0-9][a-zA-Z0-9\-]*)?' access-logs | sort -r | uniq -c
-P -> Perl regex
-o -> display only matched text not line containing matched text
regex to match websites
access-logs -> file to read from
sort -r -> sort in alphabetical order
uniq -c -> show unique matches with counts

Possessive Quantifiers
<.*>
. -> wildcard matches any single character
quantifiers are by nature greedy, matching as many characters as possible
<.*> -> matches all of `<i>regex</i>` not just the <i> tags
\*.*\* matches `*Regular expressions*, sometimes know as *regex*`
use a question mark to match in a non-greedy way
<.*?> matches <i> and <\i> not the whole expression
\*.*?\* matches `*Regular expressions` and `*regex*` not the whole expression
? -> repeat token as few times as possible when used after . or *

match an email address
[a-zA-Z0-9\!\#\$\%\&\'\*\+\-\/\=\?\^\_\`\{\|\}\~\.]+@[a-zA-Z0-9][a-zA-Z0-9\-]*\.[a-zA-Z0-9]{2,63}
grep -Po "[a-zA-Z0-9\!\#\$\%\&\'\*\+\-\/\=\?\^\_\`\{\|\}\~\.]+@[a-zA-Z0-9][a-zA-Z0-9\-]*\.[a-zA-Z0-9]{2,63}" customer-data.txt | sort > emails.txt
searches a list of customer data to grab email addresses, sort them and put them into a file called emails.txt

More character classes
match all states except DE
\b[^D\d\s][^E\d\s]\b
[] -> defined character class
^ -> signifies not to match the following tokens when contained in a class
D -> literal character
\d -> any digit 0-9
\s -> -> any whitespace character
for XML, .net, XPath a few others there is a way to subtract from a range

Backreferences
Match all header tags except H1
<([Hh][2-3]).*?>.+?<\/\1>
Match only HTML tags to strip out
<[^>]*>
grep -o -P "<([Hh][2-3]).*?>.+?<\/\1>" study-guide.html | sed 's/<[^>]*>//g' > toc.txt
find all of the lines that are not in h1 tags, strips out the tags, then outputs to a file


